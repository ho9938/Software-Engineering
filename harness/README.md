# Introduction

This demo will help you understand how to write a test harness in order to fuzz a library with AFL.

Check out the diagram below that shows main interactions with AFL:  
<br>
![afl overview](./overview.svg)


# Basics

Assume that you have a library that you want to fuzz (`library.h` and `library.c`). 

The code in `library.c` contains two functions:
```c
// an 'nprintf' implementation - print the first len bytes of data
void lib_echo(char *data, ssize_t len);

// optimised multiply - returns x*y
int lib_mul(int x, int y);
```

How can we fuzz it?
1. The code needs to be *compiled* into a program.
2. The code needs to be *instrumented*.
3. The code needs to have an *entry point* so that AFL is able to feed its generated data into the library.

Let's look at how we can accomplish these goals.


# Harness

## harness.c
For the purposes of this demo, let's fuzz `lib_echo()`. Here is a prepared `harness.c`:

```c
#include <unistd.h>
#include <string.h>
#include <stdio.h>

#include "library.h"

#define SIZE 50

int main() {
    // make sure buffer is initialized to eliminate variable behaviour that isn't dependent on the input.
    char input[SIZE] = {0};

    ssize_t length;
    length = read(STDIN_FILENO, input, SIZE);

    lib_echo(input, length);
}
```

What `harness.c` does is straightforward: it reads some input from `stdin` and passes it to `lib_echo()`. In other words, it serves as an entry point to the library. 

## Compilation
Let's compile our harness and the library:

```
AFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness
```

Here, we are using a modified version of a C compiler, `afl-clang-fast`, that includes instrumentation functionality. `AFL_HARDEN=1` tells the compiler to include some additional instrumentation. AFL needs code to be instrumented in order to work efficiently. 

We have accomplished all three goals stated in the Basics section above (compilation, instrumentation, entry point). Let's get running. 

## Running as is
Let's run our harness with a sample input from a keyboard:

```
$ ./harness
Hello World!
Hello World!
```

It would be much simpler if we could feed the input from a file:
```bash
mkdir input
echo Hello > input/buggy
./harness < input/buggy
```

Produces the following output:
```
Hello
```

## Running with AFL

If you look carefully, you will see that `lib_echo()` contains an `assert(0)` statement. This is an artificial bug we introduced in order to test AFL. In order to find it, AFL needs to generate a string starting with `bug!`. Can AFL succeed?

Let's now fuzz with AFL:

```
afl-fuzz -i input/ -o out/ ./harness
```

`-i` option tells AFL where seeds are located, `-o` tells AFL where to store the results of fuzzing.

When you run AFL for the first time, there is a high chance you will encounter a couple of errors. In this case, refer to the **Errors running AFL** section at the end of this readme.  

After you run the command above, you will see a [status screen](https://www.markdownguide.org/basic-syntax/) that shows how AFL is doing. 

# Reproducing the bug

At the moment of writing this, it took around 13 seconds to find a bug with an average of 6500 executions per second. Crashing test inputs generated by AFL are located in `out/default/crashes/`. Let's run our harness with a buggy input generated by AFL:

```bash
# Note that the file name of the crashing input may be different in your case.  
./harness < out/default/crashes/id\:000000\,sig\:06\,src\:000004+000003\,time\:10419\,op\:splice\,rep\:4
```

produces the following output:
```
harness: library.c:22: void lib_echo(char *, ssize_t): Assertion `0' failed.
Aborted (core dumped)
```

Let's check the input itself:
```
$ cat out/default/crashes/id\:000000\,sig\:06\,src\:000004+000003\,time\:10419\,op\:splice\,rep\:4
bug!Hello
```

We were able to successfully find a bug in a library using AFL!

# Errors running AFL

## 1

### Error
```
[-] Hmm, your system is configured to send core dump notifications to an
    external utility. This will cause issues: there will be an extended delay
    between stumbling upon a crash and having this information relayed to the
    fuzzer via the standard waitpid() API.
    If you're just testing, set 'AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1'.

    To avoid having crashes misinterpreted as timeouts, please log in as root
    and temporarily modify /proc/sys/kernel/core_pattern, like so:

    echo core >/proc/sys/kernel/core_pattern
```
### Solution
Just run
```bash
echo core >/proc/sys/kernel/core_pattern
```

## 2

### Error
```
[-] Whoops, your system uses on-demand CPU frequency scaling, adjusted
    between 2148 and 3515 MHz. Unfortunately, the scaling algorithm in the
    kernel is imperfect and can miss the short-lived processes spawned by
    afl-fuzz. To keep things moving, run these commands as root:

    cd /sys/devices/system/cpu
    echo performance | tee cpu*/cpufreq/scaling_governor

    You can later go back to the original state by replacing 'performance'
    with 'ondemand' or 'powersave'. If you don't want to change the settings,
    set AFL_SKIP_CPUFREQ to make afl-fuzz skip this check - but expect some
    performance drop.
```
### Solution
Just run
```bash
cd /sys/devices/system/cpu
echo performance | tee cpu*/cpufreq/scaling_governor
```
